import * as grpc from '@grpc/grpc-js';
import { AddDataSourceRequest, AddDataSourceResponse, CloseConfigRequest, CloseConfigResponse, CreateConfigRequest, CreateConfigResponse, DeleteDataSourceRequest, DeleteDataSourceResponse, ExportConfigRequest, ExportConfigResponse, GetDataSourcesRequest, GetDataSourcesResponse, ImportConfigRequest, ImportConfigResponse } from './szconfig/szconfig_pb';
import { SzConfigClient } from './szconfig/szconfig_grpc_pb';
import { SzConfig } from './abstracts/szConfig';
import { newException } from './szHelpers';
import { SzError, SzNoGrpcConnectionError } from './senzing/SzError';
import { ADD_DATASOURCE_RESPONSE } from './types/szConfig';
import { DEFAULT_CONNECTION_STRING, DEFAULT_CREDENTIALS, DEFAULT_CHANNEL_OPTIONS, DEFAULT_CONNECTION_READY_TIMEOUT, SzGrpcEnvironmentOptions } from './szGrpcEnvironment';
import { SzGrpcBase } from './abstracts/szGrpcBase';

// strong typed version of the default abstract options specific to this implementation 
// prevents accidentally passing the wrong type of client to constructor
/** options to initialize SzConfig class */
export interface SzGrpcConfigOptions extends SzGrpcEnvironmentOptions { 
    client?: SzConfigClient
}

/**
 * SzConfig
 * Access the Senzing Config module via gRPC
 * @group SzGrpcClasses
 * @hideconstructor
 * @class
 */
export class SzGrpcConfig extends SzGrpcBase implements SzConfig {
    private _client: SzConfigClient;
    /** See {@link https://github.com/senzing-garage/knowledge-base/blob/main/lists/senzing-component-ids.md} */
    public productId = "5050";

    /** 
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    public set client(value: SzConfigClient) {
        this._client = value;
    }
    /** 
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    public get client(): SzConfigClient {
        return this._client;
    }

    constructor(parameters: SzGrpcConfigOptions) {
        const { connectionString, credentials, client, grpcOptions, grpcConnectionReadyTimeOut } = parameters;
        super(parameters);
        if(client) {
            // if client was passed in use/reuse that
            this._client            = client;
        } else if(connectionString) {
            // otherwise create client from options passed in
            this._client             = new SzConfigClient(
                connectionString ? connectionString : DEFAULT_CONNECTION_STRING, 
                credentials ? credentials : DEFAULT_CREDENTIALS,
                grpcOptions ? grpcOptions : DEFAULT_CHANNEL_OPTIONS
            );
        } else {
            // no client or connection params, throw
            throw new Error(`not enough parameters to initialize`);
        }
    }
    /**
     * Adds a data source to an existing in-memory configuration.
     * @param configHandle An identifier of an in-memory configuration. Usually created by the {@link SzGrpcConfig#createConfig} or {@link SzGrpcConfig#importConfig} methods.
     * @param dataSourceCode Name of data source code to add.
     * @returns {Promise<string>} JSON document listing the newly created data source
     */
    addDataSource(configHandle: number, dataSourceCode: string) {
        return new Promise<string>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new AddDataSourceRequest();
                request.setConfigHandle(configHandle);
                request.setDataSourceCode(dataSourceCode);
    
                this.client.addDataSource(request, (err, res: AddDataSourceResponse) => {
                    if(err) {
                        reject( newException(err.details) )
                        return;
                    }
                    let result = res.getResult();
                    resolve(result);
                });
            })
        });
    }
    /**
     * Adds multiple data sources to an existing in-memory configuration.
     * @param {number} configHandle 
     * @param {string[]} dataSourceCodes 
     * @returns {Promise<string[]>} JSON documents for each datasource listing the newly created data source
     */
    addDataSources(configHandle: number, dataSourceCodes: string[]) {
        /** 
         * Attempting to create multiple datasources asynchonously ends up causing a connection closed error.
         * JavaScript/TypeScript does not have a good paradigm for synchronously requesting promises one after the other. 
         * (technically we could use generators but google's protoc generated files do not support ESM which would be required for 
         * using "async" and "await" so that leaves us with recursive function calls). Asking the end user to come up 
         * with that logic on their own might be a bit daunting so I'm providing this convenience method that 
         * handles it for them.
         */
        /** private class used for managing sequential requests */
        let addDataSourcesSequentially = (dataSources: string[], configHandle: number, callback?: Function) => {
            let _dataSources    = dataSources;
            let _configHandle   = configHandle;
            let _callback: Function | undefined;
            let _onComplete: Promise<string[]>;
            let _responses: string[] = [];

            // define subs
            let next = () => {
                let dsName = _dataSources.shift();
                if(!dsName || dsName == undefined) {
                    // we're done
                    onComplete();
                    return;
                }
                //return new Promise((resolve, reject) => {
                    this.addDataSource(_configHandle as number, dsName as string)
                    .then((resp) => {
                        // add response to results
                        _responses.push(resp);
                        // call "getNextRequest" again
                        next();
                    })
                //})
            }
        
            let onComplete = () => {
                // when we're done call this method
                if(_callback) {
                    _callback.call(this, _responses);
                }
            }

            // initialization logic
            if(callback) {
                _callback = callback;
            }
            // set up onComplete promise now that we know the number of requests
            _onComplete = new Promise<string[]>((resolve, reject) => {
                if(_responses.length >= _dataSources.length) {
                    resolve(_responses);
                }
            });
            // if there's a callback attach it to the _onComplete promise chain
            if(callback) {
                _onComplete.then(callback as any)
            }
            // kick off the first request. (recursive method chain)
            if(_dataSources && _dataSources.length > 0) {
                next();
            }
        }
        return new Promise<string[]>((resolve, reject) => {
            let addDataSources = addDataSourcesSequentially(dataSourceCodes, configHandle as number, (results: string[], error?: Error | undefined) => {
                if(error) {
                    reject(error);
                }
                resolve(results);
            })
        });
    }
    /**
     * Cleans up the Senzing SzConfig object pointed to by the config_handle.
     * @param configHandle An identifier of an in-memory configuration. Usually created by the {@link SzGrpcConfig#createConfig} or {@link SzGrpcConfig#importConfig} methods.
     * @returns {Promise<undefined>} for async flow control.
     */
    closeConfig(configHandle: number) {
        return new Promise<boolean | undefined>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new CloseConfigRequest();
                request.setConfigHandle(configHandle);
                this.client.closeConfig(request, (err, res: CloseConfigResponse) => {
                    if(err) {
                        reject( newException(err.details) )
                        return;
                    }
                    resolve(undefined);
                });
            });
        });
    }
    /**
     * Creates an in-memory Senzing configuration from the g2config.json template configuration 
     * file located in the PIPELINE.RESOURCEPATH path. A handle is returned to identify 
     * the in-memory configuration. The handle is used by the {@link SzGrpcConfig#addDataSource}, 
     * {@link SzGrpcConfig#getDataSources}, {@link SzGrpcConfig#deleteDataSource}, 
     * and {@link SzGrpcConfig#exportConfig} methods. 
     * The handle is terminated by the {@link SzGrpcConfig#closeConfig} method.
     * @returns {Promise<number>} pointer to an in-memory Senzing configuration
     */
    createConfig(): Promise<number | SzError> {
        return new Promise<number | SzError>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new CreateConfigRequest();
                this.client.createConfig(request, (err, res: CreateConfigResponse) => {
                    if(err) {
                        reject( newException(err.details) );
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(res.getResult() as number);
                });
            });
        });
    }
    /**
     * Removes a data source from an existing in-memory configuration.
     * @param configHandle An identifier of an in-memory configuration. Usually created by the {@link SzGrpcConfig#createConfig} 
     * or {@link SzGrpcConfig#importConfig} methods.
     * @param dataSourceCode Name of data source code to delete.
     * @returns {Promise<undefined>} for async flow control
     */
    deleteDataSource(configHandle: number, dataSourceCode: string) {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new DeleteDataSourceRequest();
                request.setConfigHandle(configHandle);
                request.setDataSourceCode(dataSourceCode);

                this.client.deleteDataSource(request, (err, res: DeleteDataSourceResponse) => {
                    if(err) {
                        reject( newException(err.details) )
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(true);
                });
            });
        });
    }
    /**
     * Creates a JSON string representation of the Senzing SzConfig object.
     * @param configHandle  An identifier of an in-memory configuration. Usually created by the {@link SzGrpcConfig#createConfig} or {@link SzGrpcConfig#importConfig} methods.
     * @returns {Promise<string>} containing a JSON Document representation of the Senzing SzConfig object.
     */
    exportConfig(configHandle: number) {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new ExportConfigRequest();
                request.setConfigHandle(configHandle);
                this.client.exportConfig(request, (err, res: ExportConfigResponse) => {
                    if(err) {
                        reject( newException(err.details) )
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(res.getResult());
                });
            });
        });
    }
    /**
     * Returns a JSON document of data sources contained in an in-memory configuration.
     * @param configHandle An identifier of an in-memory configuration. Usually created by the {@link SzGrpcConfig#createConfig} or {@link SzGrpcConfig#importConfig} methods.
     * @returns {Promise<string[]>} containing a JSON document listing all of the data sources.
     */
    getDataSources(configHandle: number): Promise<string[]> {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }

                const request = new GetDataSourcesRequest();
                request.setConfigHandle(configHandle);
                this.client.getDataSources(request, (err, res: GetDataSourcesResponse) => {
                    if(err) {
                        reject( newException(err.details) )
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(JSON.parse(res.getResult()));
                });
            });
        });
    }
    /**
     * Initializes an in-memory Senzing SzConfig object from a 
     * JSON string. A handle is returned to identify the in-memory configuration. 
     * The handle is used by the {@link SzGrpcConfig#addDataSource}, {@link SzGrpcConfig#getDataSources}, 
     * {@link SzGrpcConfig#deleteDataSource}, and {@link SzGrpcConfig#exportConfig} methods. 
     * The handle is terminated by the {@link SzGrpcConfig#closeConfig} method.
     * @param configDefinition 
     * @returns {Promise<number>}
     */
    importConfig(configDefinition: string) {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new ImportConfigRequest();
                request.setConfigDefinition(configDefinition);
                this.client.importConfig(request, (err, res: ImportConfigResponse) => {
                    if(err) {
                        reject( newException(err.details) )
                        return;
                    }
                    resolve(res.getResult() as number);
                });
            });
        });
    }
}