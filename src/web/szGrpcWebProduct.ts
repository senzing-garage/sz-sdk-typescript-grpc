import * as grpc from '@grpc/grpc-js';
import { GetVersionRequest, GetVersionResponse, GetLicenseRequest, GetLicenseResponse } from '../szproduct/szproduct_pb';
import { SzProductClient } from '../../src/szproduct/SzproductServiceClientPb';
import { SzProduct } from '../abstracts/szProduct';
import { SzError, SzNoGrpcConnectionError } from '../senzing/SzError';
import { DEFAULT_CHANNEL_OPTIONS, DEFAULT_CONNECTION_READY_TIMEOUT, DEFAULT_CONNECTION_STRING, DEFAULT_CREDENTIALS, SzGrpcWebEnvironmentOptions } from './szGrpcWebEnvironment';
import { SzGrpcBase } from '../abstracts/szGrpcBase';

/** 
 * options to initialize the {@link:SzGrpcProduct} class with 
 */
export interface SzGrpcWebProductOptions extends SzGrpcWebEnvironmentOptions { 
    client?: SzProductClient
}

/**
 * Access the Senzing Product module via gRPC
 * 
 * @group SzGrpcClasses
 * @hideconstructor
 * @class
 */
export class SzGrpcWebProduct extends SzGrpcBase implements SzProduct {
    /** @ignore */
    private _client: SzProductClient;

    /** See {@link https://github.com/senzing-garage/knowledge-base/blob/main/lists/senzing-component-ids.md} */
    public productId = "5056";
    
    /** 
     * the client is the grpc client class generated by protoc 
     * @ignore
     */
    public set client(value: SzProductClient) {
        this._client = value;
    }
    /** the client is the grpc client class generated by protoc 
     * @ignore
    */
    public get client(): SzProductClient {
        return this._client;
    }

    constructor(parameters: SzGrpcWebProductOptions) {
        const { connectionString, credentials, client, grpcOptions, grpcConnectionReadyTimeOut } = parameters;
        super(parameters);
        if(grpcConnectionReadyTimeOut) {
            this.grpcConnectionReadyTimeOut = grpcConnectionReadyTimeOut;
        }
        if(client) {
            // if client was passed in use/reuse that
            this._client            = client;
        } else if(connectionString) {
            // otherwise create client from options passed in
            this._client             = new SzProductClient(
                connectionString ? connectionString : DEFAULT_CONNECTION_STRING, 
                null,
                grpcOptions ? grpcOptions : DEFAULT_CHANNEL_OPTIONS
            );
        } else {
            // no client or connection params, throw
            throw new Error(`not enough parameters to initialize`);
        }
    }
    /**
     * Retrieves information about the currently used license.
     * @returns {Promise<{[key: string]: any}>} JSON document containing Senzing license metadata.
     */
    getLicense(): Promise<{[key: string]: any}> {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            //this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                /*if(err) {
                    reject( err )
                    return;
                }*/
                const request = new GetLicenseRequest();
                this.client.getLicense(request, null, (err, res: GetLicenseResponse) => {
                    if(err) {
                        reject(err)
                        return;
                    }
                    let result = JSON.parse(res.getResult());
                    //console.log("RESPONSE:\n\r", result);
                    resolve(result);
                });
            //});
        });
    }
    /**
     * Returns the version of Senzing.
     * @returns {Promise<{[key: string]: any}>} JSON document containing metadata about the Senzing Engine version being used.
     */
    getVersion(): Promise<{[key: string]: any}> {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            //this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                /*if(err) {
                    reject( err )
                    return;
                }*/
                const request = new GetVersionRequest();
                this.client.getVersion(request, null, (err, res: GetVersionResponse) => {
                    if(err) {
                        reject(err)
                        return;
                    }
                    let result = JSON.parse(res.getResult());
                    //console.log("RESPONSE:\n\r", result);
                    resolve(result);
                });
            //});
        });
    }
}