import * as grpc from '@grpc/grpc-js';
import { CheckDatastorePerformanceRequest, CheckDatastorePerformanceResponse, GetDatastoreInfoRequest, GetDatastoreInfoResponse, GetFeatureRequest, GetFeatureResponse, PurgeRepositoryRequest, PurgeRepositoryResponse, ReinitializeRequest, ReinitializeResponse } from './szdiagnostic/szdiagnostic_pb';
import { SzDiagnosticClient } from './szdiagnostic/szdiagnostic_grpc_pb';
import { SzDiagnostic } from './abstracts/szDiagnostic';
import { newException } from './szHelpers';
import { SzError, SzNoGrpcConnectionError } from './senzing/SzError';
import { CHECK_DATASTORE_PERFORMANCE_RESPONSE } from './types/szDiagnostic';
import { DEFAULT_CHANNEL_OPTIONS, DEFAULT_CONNECTION_READY_TIMEOUT, DEFAULT_CONNECTION_STRING, DEFAULT_CREDENTIALS, SzGrpcEnvironmentOptions } from './szGrpcEnvironment';
import { SzGrpcBase } from './abstracts/szGrpcBase';

export interface SzGrpcDiagnosticOptions extends SzGrpcEnvironmentOptions { 
    client?: SzDiagnosticClient
}

/**
 * SzGrpcDiagnostic
 * Access the Senzing Diagnostic module via gRPC
 * 
 * @class
 * @name SzGrpcDiagnostic
 */
export class SzGrpcDiagnostic extends SzGrpcBase implements SzDiagnostic {
    /** @internal */
    private _client: SzDiagnosticClient;
    /** See {@link https://github.com/senzing-garage/knowledge-base/blob/main/lists/senzing-component-ids.md} */
    public productId = "5052";
    
    /** 
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: module:SzGrpcEnvironment} but shouldn't be in the docs.
     * @internal
     */
    public set client(value: SzDiagnosticClient) {
        this._client = value;
    }
    /** 
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: module:SzGrpcEnvironment} but shouldn't be in the docs.
     * @internal
     */
    public get client(): SzDiagnosticClient {
        return this._client;
    }

    constructor(parameters: SzGrpcDiagnosticOptions) {
        const { connectionString, credentials, client, grpcOptions, grpcConnectionReadyTimeOut } = parameters;
        super(parameters);

        if(client) {
            // if client was passed in use/reuse that
            this._client            = client;
        } else if(connectionString) {
            // otherwise create client from options passed in
            this._client             = new SzDiagnosticClient(
                connectionString ? connectionString : DEFAULT_CONNECTION_STRING, 
                credentials ? credentials : DEFAULT_CREDENTIALS,
                grpcOptions ? grpcOptions : DEFAULT_CHANNEL_OPTIONS
            );
        } else {
            // no client or connection params, throw
            throw new Error(`not enough parameters to initialize`);
        }
    }
    /**
     * Performs inserts to determine rate of insertion.
     * @param secondsToRun Duration of the test in seconds.
     * @returns {Promise<CHECK_DATASTORE_PERFORMANCE_RESPONSE>} A JSON document
     */
    checkDataStorePerformance(secondsToRun: number): Promise<CHECK_DATASTORE_PERFORMANCE_RESPONSE | SzError> {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new CheckDatastorePerformanceRequest();
                request.setSecondstorun(secondsToRun);
                this.client.checkDatastorePerformance(request, (err, res: CheckDatastorePerformanceResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let result = JSON.parse(res.getResult()) as CHECK_DATASTORE_PERFORMANCE_RESPONSE;
                    //console.log("RESPONSE:\n\r", result, res.getResult().toString());
                    resolve(result);
                });
            });
        });
    }
    /**
     * Returns details of the datastore currently in use by Senzing.
     * @returns {Promise<string>}
     */
    getDatastoreInfo(): Promise<string> {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new GetDatastoreInfoRequest();
                this.client.getDatastoreInfo(request, (err, res: GetDatastoreInfoResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let result = res.getResult();
                    //console.log("RESPONSE:\n\r", result);
                    resolve(result);
                });
            });
        });
    }
    /**
     * Returns diagnostic information of a feature. Not recommended for use.
     * @experimental
     * @param featureId The identifier of the feature to describe.
     * @returns {Promise<string>} A string containing a JSON document
     */
    getFeature(featureId: number): Promise<string> {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new GetFeatureRequest();
                request.setFeatureid(featureId);
                this.client.getFeature(request, (err, res: GetFeatureResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let result = res.getResult();
                    //console.log("RESPONSE:\n\r", result);
                    resolve(result);
                });
            });
        });
    }
    /**
     * Removes every record in the Senzing repository.
     * @returns {Promise<undefined>} for async flow control.
     */
    purgeRepository(): Promise<undefined> {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new PurgeRepositoryRequest();
                this.client.purgeRepository(request, (err, res: PurgeRepositoryResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    resolve(undefined);
                });
            });
        });
    }
    /**
     * Used by {@link SzGrpcEnvironment}. Not intended to be called directly by end-users.
     * @internal
     * @param configId 
     */
    reinitialize(configId: number): Promise<undefined | SzError> {
        return new Promise((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new ReinitializeRequest();
                request.setConfigid(configId);
                this.client.reinitialize(request, (err, res: ReinitializeResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    resolve(undefined);
                });
            });
        });
    }
}