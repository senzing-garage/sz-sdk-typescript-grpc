import * as grpc from '@grpc/grpc-js';
import { GetConfigRequest, GetConfigResponse, GetConfigsRequest, GetConfigsResponse, GetDefaultConfigIdRequest, GetDefaultConfigIdResponse, GetTemplateConfigRequest, GetTemplateConfigResponse, RegisterConfigRequest, RegisterConfigResponse, ReplaceDefaultConfigIdRequest, ReplaceDefaultConfigIdResponse, SetDefaultConfigIdRequest, SetDefaultConfigIdResponse, SetDefaultConfigRequest, SetDefaultConfigResponse} from './szconfigmanager/szconfigmanager_pb';
import { SzConfigClient } from './szconfig/szconfig_grpc_pb';
import { SzConfigManagerClient } from './szconfigmanager/szconfigmanager_grpc_pb';
import { SzConfigManager } from './abstracts/szConfigManager';
import { newException } from './szHelpers';
import { SzError, SzNoGrpcConnectionError } from './senzing/SzError';
import { DEFAULT_CHANNEL_OPTIONS, DEFAULT_CONNECTION_READY_TIMEOUT, DEFAULT_CONNECTION_STRING, DEFAULT_CREDENTIALS, SzGrpcEnvironmentOptions } from './szGrpcEnvironment';
import { SzGrpcBase } from './abstracts/szGrpcBase';
import { SzGrpcConfig, SzGrpcConfigOptions } from './szGrpcConfig';

// strong typed version of the default abstract options specific to this implementation 
// prevents accidentally passing the wrong type of client to constructor
/** options to initialize SzConfigManager class */
export interface SzGrpcConfigManagerOptions extends SzGrpcEnvironmentOptions { 
    client?: SzConfigManagerClient,
    configClient?: SzConfigClient
}

/**
 * SzGrpcConfigManager
 * Access the Senzing ConfigManager module via gRPC
 * 
 * @group SzGrpcClasses
 * @hideconstructor
 * @class
 */
export class SzGrpcConfigManager extends SzGrpcBase implements SzConfigManager {
    private _client;
    private _configClient: SzConfigClient | undefined;
    private _parameters: SzGrpcConfigManagerOptions; 
    /** See {@link https://github.com/senzing-garage/knowledge-base/blob/main/lists/senzing-component-ids.md} */
    public productId = "5051";

    /**
     * used for telling classes not to use live clients 
     * @ignore */
    private isTestEnvironment: boolean = false;

    /** 
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: module:SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    public set client(value: SzConfigManagerClient) {
        this._client = value;
    }
    /** 
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: module:SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    public get client(): SzConfigManagerClient {
        return this._client;
    }
    /**
     * @internal
     */
    private get grpcParameters(): SzGrpcEnvironmentOptions {
        let res = this._parameters as any;
        return res;
    }

    /**
     * Creates a new {@link SzGrpcConfig} instance using the default
     * configuration template and returns the {@link SzGrpcConfig}
     * representing that configuration.
     */
    public createConfig(): Promise<SzGrpcConfig>;
    /**
     * Gets the configuration definition that is registered with the
     * specified config ID and returns a new {@link SzGrpcConfig} instance
     * representing that configuration.
     */
    public createConfig(configId: number): Promise<SzGrpcConfig>;
    /**
     * Creates a new {@link SzGrpcConfig} instance using the specified
     * configuration definition and returns the {@link SzGrpcConfig}
     * representing that configuration.
     * @param configDefinition 
     */
    public createConfig(configDefinition: string): Promise<SzGrpcConfig>;
    /** @internal */
    public createConfig(definitionOrConfigId?: string | number): Promise<SzGrpcConfig> {
        if(this.isTestEnvironment) {
            return this.createConfigForTests();
        }
        if(definitionOrConfigId) {
            if(typeof definitionOrConfigId == 'number') {
                // get new SzConfig from configId
                return this.createConfigFromConfigId(definitionOrConfigId as number);
            } else {
                // get new SzConfig from configDefinition
                return this.createConfigFromDefinition(definitionOrConfigId as string);
            }
        }
        // when no args get from template
        return this.createConfigFromTemplate();
    }
    /**
     * Get the Configuration Document for the default configuration template.
     * @returns {Promise<string>} the configuration document
     */
    public getTemplateConfig(): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new GetTemplateConfigRequest();
                this.client.getTemplateConfig(request, (err, res: GetTemplateConfigResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve( res.getResult() );
                });
            });
        });
    }
    /**
     * Registers the configuration described by the specified
     * configuration definition in the repository with the specified
     * comment. If a comment has not been provided an autogenerated one will be used.
     * @param configDefinition The configuration definition to register.
     * @param comment The comments for the configuration.
     * @returns {Promise<void>} The identifier for referencing the config in the entity repository.
     * 
     * @throws SzException If a failure occurs.
     */
    registerConfig(configDefinition: string, comment?: string) {
        return new Promise<number>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new RegisterConfigRequest();
                request.setConfigDefinition(configDefinition);
                if(comment) request.setConfigComment(comment);
                this.client.registerConfig(request, (err, res: RegisterConfigResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(res.getResult());
                });
            });
        });
    }
    /**
     * Gets the list of saved configuration ID's with their comments and
     * timestamps and return the JSON describing them.
     * 
     * @returns {Promise<string>} JSON document describing the configurations registered
     * in the entity repository with their identifiers, timestamps and comments.
     */
    getConfigs(): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new GetConfigsRequest();
                this.client.getConfigs(request, (err, res: GetConfigsResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(res.getResult());
                });
                return undefined;
            });
        });
    }
    /**
     * Gets the configuration ID of the default configuration for the repository
     * and returns it.  If the entity repository is in the initial state and the
     * default configuration ID has not yet been set, then zero (0) is returned.
     * @returns {Promise<number>} identifier which identifies the current configuration in use.
     */
    getDefaultConfigId(): Promise<number> {
        return new Promise<number>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new GetDefaultConfigIdRequest();
                this.client.getDefaultConfigId(request, (err, res: GetDefaultConfigIdResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve( res.getResult() );
                });
            });

            return -1;
        });
    }

    /**
     * Registers the specified config definition with an autogenerated comment 
     * and then sets the default configuration ID for the repository to the
     * configuration ID that is the result of that registration, returning
     * the config ID under which the configuration was registered.
     * @param configDefinition The configuration definition to register as the default.
     * @returns {Promise<number>}The configuration ID under which the configuration was registered.
     * @returns {Promise<SzException>} If a failure occurs.
     */
    setDefaultConfig(configDefinition: string): Promise<number>;
    /**
     * Registers the specified config definition with the specified comment
     * and then sets the default configuration ID for the repository to the
     * configuration ID that is the result of that registration, returning
     * the config ID under which the configuration was registered.
     * @param configDefinition The configuration definition to register as the default.
     * @param configComment The comments for the configuration.
     * @returns {Promise<number>}The configuration ID under which the configuration was registered.
     * @returns {Promise<SzException>} If a failure occurs.
     */
    setDefaultConfig(configDefinition: string, comment: string): Promise<number>;
    /** @internal */
    setDefaultConfig(configDefinition: string, comment?: string): Promise<number | SzError> | undefined {
        return new Promise<number>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new SetDefaultConfigRequest();
                request.setConfigDefinition(configDefinition);
                if(comment) request.setConfigComment(comment);

                this.client.setDefaultConfig(request, (err, res: SetDefaultConfigResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    resolve(res.getResult())
                });
            });
        });
    }
    /**
     * Sets the default configuration for the repository to the specified
     * configuration ID.
     * 
     * @see replaceDefaultConfigId
     * @param configId The configuration identifier of the Senzing Engine configuration to use as the default.
     * @returns {Promise<undefined>} for async flow control
     */
    setDefaultConfigId(configId: number): Promise<number | SzError> | undefined {
        return new Promise<number>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new SetDefaultConfigIdRequest();
                request.setConfigId(configId);
                this.client.setDefaultConfigId(request, (err, res: SetDefaultConfigIdResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    resolve( configId );
                });
            });
        });
    }

    constructor(parameters: SzGrpcConfigManagerOptions) {
        const { connectionString, credentials, client, configClient, grpcOptions, isTestEnvironment, grpcConnectionReadyTimeOut } = parameters;
        super(parameters);
        this._parameters = parameters;
        if(isTestEnvironment !== undefined) {
            this.isTestEnvironment = isTestEnvironment;
        }
        if(configClient) {
            this._configClient = configClient;
        }
        if(client) {
            // if client was passed in use/reuse that
            this._client            = client;
        } else if(connectionString) {
            // otherwise create client from options passed in
            this._client             = new SzConfigManagerClient(
                connectionString ? connectionString : DEFAULT_CONNECTION_STRING, 
                credentials ? credentials : DEFAULT_CREDENTIALS,
                grpcOptions ? grpcOptions : DEFAULT_CHANNEL_OPTIONS
            );
        } else {
            // no client or connection params, throw
            throw new Error(`not enough parameters to initialize`);
        }
    }
    /**
     * Replaces the old configuration identifier with a new configuration identifier 
     * in the Senzing database. It is like a “compare-and-swap” instruction to serialize 
     * concurrent editing of configuration. If {@param currentDefaultConfigId} is no longer 
     * the “current configuration identifier”, the operation will fail. To simply set 
     * the default configuration ID, use {@link setDefaultConfigId}.
     * 
     * @param currentDefaultConfigId The configuration identifier to replace.
     * @param newDefaultConfigId  The configuration identifier to use as the default.
     * @returns {Promise<undefined>} for async flow control
     */
    replaceDefaultConfigId(currentDefaultConfigId: number, newDefaultConfigId: number) {
        return new Promise<string>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new ReplaceDefaultConfigIdRequest();
                request.setCurrentDefaultConfigId(currentDefaultConfigId);
                request.setNewDefaultConfigId(newDefaultConfigId);
                this.client.replaceDefaultConfigId(request, (err, res: ReplaceDefaultConfigIdResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return
                    }
                });
            });
        });
    }

    // ------------------------------- non public methods -------------------------------
    /** @internal */
    get szConfigGrpcOptions(): SzGrpcConfigOptions {
        let _options: SzGrpcConfigOptions = this.grpcParameters as SzGrpcConfigOptions;
        delete _options.client;
        if(this._configClient) _options.client = this._configClient;
        return _options;
    }
    /** @internal */
    private createConfigFromDefinition(configDefinition: string) {
        return new Promise<SzGrpcConfig>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const res = new SzGrpcConfig(this.szConfigGrpcOptions);
                res.definition = configDefinition;
                res.verifyConfig();
                resolve(res);
            });
        });
    }
    /** @internal */
    private createConfigFromConfigId(configId: number) {
        return new Promise<SzGrpcConfig>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                const request = new GetConfigRequest();
                request.setConfigId(configId);
                this.client.getConfig(request, (err, res: GetConfigResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let configDefinition = res.getResult();
                    const conf = new SzGrpcConfig(this.szConfigGrpcOptions);
                    conf.definition = configDefinition;
                    resolve(conf);
                });
            });
        });
    }
    /** @interal */
    private createConfigFromTemplate() {
        return new Promise<SzGrpcConfig>((resolve, reject) => {
            if(!this.client){
                reject(new SzNoGrpcConnectionError());
                return
            }
            this.client.waitForReady(this.getDeadlineFromNow(), (err) => {
                if(err) {
                    reject( err )
                    return;
                }
                //const res = new SzGrpcConfig(this.grpcParameters as SzGrpcConfigOptions);
                //res.configDefinition = configDefinition;
                //res.verifyConfig();
                //resolve(res);
                const request = new GetTemplateConfigRequest();
                this.client.getTemplateConfig(request, (err, res: GetTemplateConfigResponse) => {
                    if(err) {
                        let _err = newException(err.details);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let configDefinition = res.getResult();
                    const conf = new SzGrpcConfig(this.szConfigGrpcOptions);
                    conf.definition = configDefinition;
                    //console.log("RESPONSE:\n\r", result);
                    resolve(conf);
                });
            });
        });
    }
    /**
     * Used for unit tests, avoids needing live grpc client connection
     * @ignore 
     */
    private createConfigForTests() {
        return new Promise<SzGrpcConfig>((resolve, reject)=>{
            const conf = new SzGrpcConfig(this.szConfigGrpcOptions);
            resolve(conf);
        })
    }
}